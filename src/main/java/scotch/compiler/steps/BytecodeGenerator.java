package scotch.compiler.steps;

import static java.util.Arrays.asList;
import static java.util.stream.Collectors.toList;
import static me.qmx.jitescript.JDKVersion.V1_8;
import static me.qmx.jitescript.util.CodegenUtils.c;
import static me.qmx.jitescript.util.CodegenUtils.p;
import static me.qmx.jitescript.util.CodegenUtils.sig;
import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
import static scotch.compiler.output.GeneratedClass.ClassType.DATA_CONSTRUCTOR;
import static scotch.compiler.syntax.reference.DefinitionReference.rootRef;
import static scotch.compiler.util.Pair.pair;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import com.google.common.collect.ImmutableList;
import me.qmx.jitescript.CodeBlock;
import me.qmx.jitescript.JiteClass;
import org.objectweb.asm.tree.LabelNode;
import scotch.compiler.error.CompileException;
import scotch.compiler.output.GeneratedClass;
import scotch.compiler.output.GeneratedClass.ClassType;
import scotch.compiler.syntax.Scoped;
import scotch.compiler.syntax.definition.Definition;
import scotch.compiler.syntax.definition.DefinitionGraph;
import scotch.compiler.syntax.reference.ClassReference;
import scotch.compiler.syntax.reference.DefinitionReference;
import scotch.compiler.syntax.reference.ModuleReference;
import scotch.compiler.syntax.scope.Scope;
import scotch.compiler.text.SourceLocation;
import scotch.compiler.util.Pair;
import scotch.runtime.Callable;
import scotch.runtime.Copyable;
import scotch.symbol.MethodSignature;
import scotch.symbol.Symbol;
import scotch.symbol.descriptor.TypeInstanceDescriptor;
import scotch.symbol.type.Type;

public class BytecodeGenerator {

    private final DefinitionGraph                   graph;
    private final Deque<Pair<JiteClass, ClassType>> classStack;
    private final List<GeneratedClass>              generatedClasses;
    private final Deque<Scope>                      scopes;
    private final Deque<List<String>>               arguments;
    private final Deque<List<String>>               matches;
    private final Deque<CaseEntry>                  cases;
    private       int                               lambdas;
    private       int                               applies;

    public BytecodeGenerator(DefinitionGraph graph) {
        this.graph = graph;
        this.classStack = new ArrayDeque<>();
        this.generatedClasses = new ArrayList<>();
        this.scopes = new ArrayDeque<>();
        this.arguments = new ArrayDeque<>(asList(ImmutableList.of()));
        this.matches = new ArrayDeque<>(asList(ImmutableList.of()));
        this.cases = new ArrayDeque<>();
    }

    public void addMatch(String name) {
        matches.peek().add(name);
    }

    public LabelNode beginCase() {
        return cases.peek().beginCase();
    }

    public void beginCases(int size) {
        cases.push(new CaseEntry(size));
    }

    public void beginClass(ClassType classType, String className, SourceLocation sourceLocation) {
        JiteClass jiteClass = new JiteClass(className);
        pushClass(jiteClass, classType);
        jiteClass.setSourceFile(sourceLocation.getPath());
    }

    public void beginConstant(String className, SourceLocation sourceLocation) {
        JiteClass jiteClass = new JiteClass(className, currentClass().getClassName(), new String[0]);
        pushClass(jiteClass, DATA_CONSTRUCTOR);
        jiteClass.setSourceFile(sourceLocation.getPath());
        jiteClass.defineDefaultConstructor();
        jiteClass.defineMethod("call", ACC_PUBLIC, sig(Object.class), new CodeBlock() {{
            aload(0);
            areturn();
        }});
    }

    public void beginConstructor(String className, SourceLocation sourceLocation) {
        JiteClass jiteClass = new JiteClass(className, currentClass().getClassName(), new String[] { p(Copyable.class) });
        pushClass(jiteClass, DATA_CONSTRUCTOR);
        jiteClass.setSourceFile(sourceLocation.getPath());
    }

    public void beginMatches() {
        matches.push(new ArrayList<>());
    }

    public CodeBlock captureApply() {
        List<String> variables = getAllVariables();
        return variables.stream()
            .map(variables::indexOf)
            .map(new CodeBlock()::aload)
            .reduce(new CodeBlock(), CodeBlock::append);
    }

    public CodeBlock captureLambda(String lambdaArgument) {
        List<String> variables = ImmutableList.<String>builder()
            .addAll(getCaptures())
            .addAll(getArguments())
            .addAll(getMatches())
            .build();
        CodeBlock block = variables.stream()
            .map(this::getVariable)
            .map(new CodeBlock()::aload)
            .reduce(new CodeBlock(), CodeBlock::append);
        getArguments().add(lambdaArgument);
        return block;
    }

    public JiteClass currentClass() {
        return classStack.peek().getLeft();
    }

    public void defineDefaultConstructor(int access) {
        currentClass().defineDefaultConstructor(access);
    }

    public CodeBlock enclose(Scoped scoped, Supplier<CodeBlock> supplier) {
        return scoped(scoped, () -> {
            arguments.push(new ArrayList<>());
            try {
                return supplier.get();
            } finally {
                arguments.pop();
            }
        });
    }

    public LabelNode endCase() {
        return cases.peek().endCase();
    }

    public LabelNode endCases() {
        return cases.pop().endCase();
    }

    public void endClass() {
        classStack.pop().into((jiteClass, type) ->
            generatedClasses.add(new GeneratedClass(type, c(jiteClass.getClassName()), jiteClass.toBytes(V1_8))));
    }

    public void endMatches() {
        matches.pop();
    }

    public void field(String fieldName, int access, String type) {
        currentClass().defineField(fieldName, access, type, null);
    }

    public void fromRoot() {
        Definition root = getDefinition(rootRef()).orElseThrow(() -> new IllegalStateException("No root found!"));
        generate(root, () -> root.generateBytecode(this));
    }

    public <T extends Scoped> void generate(T scoped, Runnable runnable) {
        enterScope(scoped);
        try {
            runnable.run();
        } finally {
            leaveScope();
        }
    }

    public List<GeneratedClass> generateBytecode() {
        if (graph.hasErrors()) {
            throw new CompileException(graph.getErrors());
        } else {
            BytecodeGenerator state = new BytecodeGenerator(graph);
            state.fromRoot();
            return state.getClasses();
        }
    }

    public void generateBytecode(List<DefinitionReference> references) {
        references.stream()
            .map(this::getDefinition)
            .filter(Optional::isPresent)
            .map(Optional::get)
            .forEach(definition -> definition.generateBytecode(this));
    }

    public Class<?>[] getCaptureAllTypes() {
        List<Class<?>> types = ImmutableList.<Class<?>>builder()
            .addAll(getCaptureTypes(getCaptures()))
            .addAll(getCaptureTypes(getLocals()))
            .addAll(getCaptureTypes(getArguments()))
            .addAll(getCaptureTypes(getMatches()))
            .build();
        return types.toArray(new Class<?>[types.size()]);
    }

    public List<GeneratedClass> getClasses() {
        return generatedClasses.stream()
            .sorted()
            .collect(toList());
    }

    public String getDataConstructorClass(Symbol symbol) {
        return scope().getDataConstructorClass(symbol);
    }

    public Class<?>[] getLambdaCaptureTypes() {
        List<Class<?>> types = ImmutableList.<Class<?>>builder()
            .addAll(getCaptureTypes(getCaptures()))
            .addAll(getCaptureTypes(getArguments().subList(0, getArguments().size() - 1)))
            .build();
        return types.toArray(new Class<?>[types.size()]);
    }

    public Class<?>[] getLambdaType() {
        List<Class<?>> types = ImmutableList.<Class<?>>builder()
            .addAll(getCaptureTypes(getCaptures()))
            .addAll(getCaptureTypes(getArguments()))
            .build();
        return types.toArray(new Class<?>[types.size()]);
    }

    public TypeInstanceDescriptor getTypeInstance(ClassReference classRef, ModuleReference moduleRef, List<Type> parameters) {
        return scope().getTypeInstance(classRef, moduleRef, parameters).get();
    }

    public MethodSignature getValueSignature(Symbol symbol) {
        return scope()
            .getValueSignature(symbol)
            .orElseThrow(() -> new IllegalStateException("Could not get value method for " + symbol));
    }

    public int getVariable(String name) {
        int offset = getAllVariables().indexOf(name);
        if (offset < 0 ) {
            Scope scope = scopes.pop();
            try {
                offset = getAllVariables().indexOf(name);
            } finally {
                scopes.push(scope);
            }
        }
        if (offset >= 0) {
            return offset;
        } else {
            throw new IllegalArgumentException("Could not find offset of variable '" + name + "'");
        }
    }

    public void method(String methodName, int access, String signature, CodeBlock body) {
        currentClass().defineMethod(methodName, access, signature, body);
    }

    public LabelNode nextCase() {
        return cases.peek().nextCase();
    }

    public void releaseLambda(String lambdaArgument) {
        getArguments().remove(lambdaArgument);
    }

    public String reserveApply() {
        return "apply$" + applies++;
    }

    public String reserveLambda() {
        return "lambda$" + lambdas++;
    }

    public Scope scope() {
        return scopes.peek();
    }

    public <T extends Scoped> CodeBlock scoped(T scoped, Supplier<CodeBlock> supplier) {
        enterScope(scoped);
        try {
            return supplier.get();
        } finally {
            leaveScope();
        }
    }

    public Class<? extends Callable> typeOf(Type type) {
        return Callable.class;
    }

    private <T extends Scoped> void enterScope(T scoped) {
        scopes.push(graph.getScope(scoped.getReference()));
    }

    private ImmutableList<String> getAllVariables() {
        return ImmutableList.<String>builder()
            .addAll(getCaptures())
            .addAll(getLocals())
            .addAll(getArguments())
            .addAll(getMatches())
            .build();
    }

    private List<String> getArguments() {
        return arguments.peek();
    }

    private List<Class<? extends Callable>> getCaptureTypes(List<String> captures) {
        return captures.stream()
            .map(Symbol::unqualified)
            .map(scope()::getValue)
            .map(value -> value.map(this::typeOf))
            .filter(Optional::isPresent)
            .map(Optional::get)
            .collect(toList());
    }

    private List<String> getCaptures() {
        return scope().getCaptures();
    }

    private Optional<Definition> getDefinition(DefinitionReference reference) {
        return graph.getDefinition(reference);
    }

    private List<String> getLocals() {
        return scope().getLocals();
    }

    private List<String> getMatches() {
        return matches.peek();
    }

    private void leaveScope() {
        scopes.pop();
    }

    private void pushClass(JiteClass jiteClass, ClassType classType) {
        classStack.push(pair(jiteClass, classType));
    }

    private static class CaseEntry {

        private final List<LabelNode> labels;
        private       int             position;

        public CaseEntry(int size) {
            labels = new ArrayList<>();
            for (int i = 0; i <= size; i++) {
                labels.add(new LabelNode());
            }
        }

        public LabelNode beginCase() {
            return labels.get(position++);
        }

        public LabelNode endCase() {
            return labels.get(labels.size() - 1);
        }

        public LabelNode nextCase() {
            return labels.get(position);
        }
    }
}
